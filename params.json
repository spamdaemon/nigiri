{"name":"Nigiri","tagline":"A simple wrapper for IndexedDB.","body":"Nigiri\r\n======\r\n\r\nThis library wraps an IndexedDB datastore in order to provide additional capabilities.\r\nNirigi closely follows the design of the [IndexedDB API](http://www.w3.org/TR/IndexedDB/) through \r\nnew functions for ObjectStore and Indexes and reinterpreting arguments for existing functions. \r\n\r\n\r\nFeatures\r\n--------\r\n\r\nNigiri provides the ability to\r\n* execute complex queries that automatically use available indexes\r\n* define a cursor with a set of keys in addition to key ranges\r\n* limit the size of a result set\r\n* skip over the initial items in a result set\r\n* filter a result set\r\n* apply batch updates to the database\r\n* use complex queries to delete, update, and count items in the database\r\n* collect all values, primary keys, or keys that are enumerated by a query\r\n\r\n\r\nNon-Features\r\n------------\r\n\r\nNotably absent from Nigiri are promises at this point. There are several methods of the IndexedDB API that don't lend \r\nthemselves very easily to using promises.\r\n\r\n\r\nTODO\r\n----\r\n\r\nThis is the initial version of Nigiri and it is likely to have bugs:\r\n* there is no build script other than a simple Unix bash script.\r\n* the documentation is currently lacking\r\n* the event interface has not been tested\r\n* the code organization is still very rough and draft-like \r\n* only tested on Chrome and Firefox so far\r\n* error handling for batch operations are not that well defined\r\n\r\n\r\nUnit Testing\r\n------------\r\n\r\nUnit testing is supported by [Jasmine](http://pivotal.github.io/jasmine/)\r\nand [Karma](http://karma-runner.github.io/0.10/index.html).\r\n\r\n\r\nContribute\r\n----------\r\n\r\nIf you find this project useful and want to report a problem, please provide a unit test case.\r\n\r\n\r\nExamples\r\n--------\r\n\r\n### KeySet\r\n\r\nUse a KeySet to find specific items in index or store. The KeySet can be used in the same way that an IDBKeyRange \r\ncan be used:\r\n```X.openCursor(new Nigiri.KeySet([ key1, key2, key3, ... ]))```\r\n\r\n```X.openKeyCursor(new Nigiri.KeySet([ key1, key2, key3, ... ]))```\r\n\r\nThe keys must be specified in sorted order.\r\n\r\n### Query\r\n\r\nUse a Query to perform more complex object store queries involving multiple fields, which are identified by their keypath. \r\n\r\n```\r\n  BOOKS.openCursor(new Nigiri.Query({\r\n    author : new Nigiri.KeySet([\"Hemingway\", \"Poe\" ]),\r\n    year   : Nigiri.KeyRange.bound(1900, 1950),\r\n  }), options)\r\n```\r\n If there are fields that are indexed, then the query will use the appropriate indexes. For fields that are not indexed,\r\n a filter is automatically created. Again, a query can be used with generic options.\r\nQueries cannot be used with indexes. Use a KeyRange or KeySet instead.\r\n\r\n### Options\r\n\r\nCursor functions that normally take a direction parameter can now take an Options parameter instead.\r\n\r\nCurrently options are\r\n* `direction`, which can be used in the same way that the standard `direction` parameter would be used.\r\n* `offset`, which can be used to skip an initial number of items that the cursor would normally return.\r\n* `limit`, which can be used to limit the number of items returned by the cursor.\r\n* `filter`, which is a boolean `function(cursor)` that can be used to ignore items that a cursor would normally return\r\n* `withValues`, is used to indicate that the cursor needs to retrieve objects from the store instead of just their keys\r\n\r\nThe following cursor enumerates only the two even items 2,4 in reverse order: \r\n```\r\n  INTEGERS.openCursor(new IDBKeyRange(0,100),new Nigiri.Options({ \r\n    offset : 3,\r\n    limit : 2,\r\n    direction : \"prev\",\r\n    filter : function(cursor) {\r\n      return (cursor.key % 2) === 0;\r\n    }\r\n  }))\r\n```\r\n \r\n### Counting, Getting, and Deleting\r\n\r\nKeySet and and Query can be used together with the count and delete functions.\r\n```\r\n\tBOOKS.count(new Nigiri.Query({\r\n\t\tyear : Nigiri.KeyRange.upperBound(2011)\r\n\t});\r\n``` \r\nmight be used to count all books before the year 2012.\r\n\r\nor \r\n```\r\n\tBOOKS[\"delete\"](new Nigiri.Query({\r\n    \tyear : Nigiri.KeyRange.upperBound(2010)\r\n\t}));\r\n``` \r\ncan be used to delete books older than 2011.\r\n\r\nAnalogous to delete and count, it is possible to use queries with the `get` and `getKey` functions\r\non an index or object store.\r\n\r\n### Updating\r\n\r\nItems in the database can easily be updated or deleted with an update function. For example,\r\nuse this to delete very old unread articles, or mark somewhat old articles as read:\r\n```\r\n  BOOKS.update(function(book) {\r\n            if (book.year < 2009) {\r\n                return undefined; // return undefined to delete the book\r\n            }\r\n            if ((now - book.year) < 1) {\r\n                return null; // don't update this item\r\n            }\r\n\r\n            book.unread = false;\r\n            return book; // return the item (or a new item) to update the entry in the database\r\n        }, new Nigiri.Query({\r\n            unread : true\r\n        }), new Nigiri.Options())\r\n```\r\n\r\n### Batch Update operations\r\n\r\nA few methods have been added to retrieve multiple records or update or add multiple records:\r\n* addAll can be used to add multiple new items to the object store\r\n* putAll can be used to add or overwrite existing items in the object store.\r\n\r\nExample usage of addAll:\r\n```\r\n\tBOOKS.addAll([ {\r\n            key : \"isbn:978-0596517748\",\r\n            title : \"JavaScript : The Good Parts\",\r\n            author : \"Crockford\",\r\n            year : 2008,\r\n            unread : true\r\n        }, {\r\n            key : \"B00CA5USBY8\",\r\n            title : \"Javascript for Beginners\",\r\n            author : \"Lassoff\",\r\n            year : 2013,\r\n            unread : true\r\n        }, {\r\n            key : \"isbn:978-1449399023\",\r\n            title : \"JavaScript & jQuery: The Missing Manual\",\r\n            author : \"McFarland\",\r\n            year : 2011,\r\n            unread : true\r\n        } ])\r\n```\r\n\r\nBasically, addAll and putAll work like their single value counterparts.\r\n\r\n### Batch Retrieval\r\nBatch retrieval methods simplify the use of the database since it avoids use of cursors:\r\n* getAll can be used to get all objects that match a query on an index or a store\r\n* getAllPrimaryKeys can be used to a sorted array of the primary keys that are selected by a query on an index or a store\r\n* getAllKeys can be used to a sorted array of the keys that are selected by a query  on an index or a store\r\n\r\nThe result of the operations are arrays of either values, primary keys, or keys. They are used like this:\r\n```\r\n\t BOOKS.getAll(new Nigiri.Query({\r\n            year : IDBKeyRange.upperBound(2012)\r\n        }), new Nigiri.Options({\r\n            direction : \"prev\"\r\n        }))\r\n```\r\n\r\nAll batch operations currently respond with a success event and report this structure as a result:\r\n```\r\n  {\r\n     successes : <number of successful operations>,\r\n     errors : <number of errors>\r\n  }\r\n```\r\n\r\nIf an onerror handler is set, then the all batch operations may invoke the handler multiple times, if the handler\r\ncalls ```preventDefault```.\r\n  \r\n\r\nPerformance\r\n-----------\r\n\r\nGenerally, the Nigiri.Queries should be performing reasonably well, unless non-indexed fields are queried. If non-indexed fields are queried, \r\nthen the object has to be retrieved from storage so that the filter function can be evaluated. When using filters or keysets, the \r\ncursor's advance function cannot skip over multiple items at a time, so use of `cursor.advance()` with values greater than one should be\r\navoided. This applies also to initial offsets greather than 1.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}